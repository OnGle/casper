#!/bin/sh
## Casper helper functions, used by casper on boot and by casper-snapshot

if [ "${BUILD_SYSTEM}" = "Ubuntu" ]; then
    MP_QUIET="-Q"
elif [ "${BUILD_SYSTEM}" = "Debian" ]; then
    MP_QUIET="-q"
else
    MP_QUIET=""
fi

if [ ! -x "/bin/fstype" ]; then
    # klibc not in path -> not in initramfs
    export PATH="${PATH}:/usr/lib/klibc/bin"
fi

sys2dev() {
    sysdev=${1#/sys}
    echo "/dev/$(udevinfo -q name -p ${sysdev} 2>/dev/null|| echo ${sysdev##*/})"
}

subdevices() {
    sysblock=$1
    r=""
    for dev in "${sysblock}" "${sysblock}"/*; do
        if [ -e "${dev}/dev" ]; then
            r="${r} ${dev}"
        fi
    done
    echo ${r}
}

get_fstype() {
    local FSTYPE
    local FSSIZE
    eval $(fstype < $1)
    if [ "$FSTYPE" != "unknown" ]; then
        echo $FSTYPE
        return 0
    fi
    /lib/udev/vol_id -t $1 2>/dev/null
}

is_supported_blockdev () {
    blockdev="${1}"
    fstype=$(get_fstype "${blockdev}")
    case ${fstype} in
        vfat|ext2|ext3) # FIXME: what about other filesystems?
            return 0
            ;;
    esac
    return 1
}

where_is_mounted() {
    device=$1
    if grep -q "^$device " /proc/mounts; then
        grep "^$device " /proc/mounts | read d mountpoint rest
        echo $mountpoint
        return 0
    fi
    return 1
}

lastline() {
    while read lines ; do
        line=${lines}
    done
    echo "${line}"
}

base_path ()
{
    testpath="${1}"
    mounts="$(awk '{print $2}' /proc/mounts)"
    testpath="$(busybox realpath ${testpath})"

    while true ; do
        if echo "${mounts}" | grep -qs "^${testpath}" ; then
            set -- `echo "${mounts}" | grep "^${testpath}" | lastline`
            echo ${1}
            break
        else
            testpath=`dirname $testpath`
        fi
    done
}

fs_size ()
{
    # Returns used/free fs kbytes + 5% more
    # You could pass a block device as $1 or the mount point as $2

    dev="${1}"
    mountp="${2}"
    used="${3}"

    if [ -z "${mountp}" ]; then
        mountp=$(where_is_mounted "${dev}")
        if [ "$?" -gt 0 ]; then
            mountp="/mnt/tmp_fs_size"
            mkdir -p "${mountp}"
            mount -t $(get_fstype "${dev}") -o ro "${dev}" "${mountp}"
            doumount=1
        fi
    fi

    if [ "${used}" = "used" ]; then
        size=$(du -ks ${mountp} | cut -f1)
        size=$(expr ${size} + ${size} / 20 ) # FIXME: 5% more to be sure
    else
        # free space
        size="$(df -k | grep -s ${mountp} | awk '{print $4}')"
    fi

    if [ -n "${doumount}" ]; then
        umount "${mountp}"
        rmdir "${mountp}"
    fi
    echo "${size}"
}

setup_loop() {
    local fspath=$1
    local module=$2
    local pattern=$3
    local offset=$4

    modprobe ${MP_QUIET} -b "$module"
    udevsettle

    for loopdev in $pattern; do
        if [ "$(cat $loopdev/size)" -eq 0 ]; then
            dev=$(sys2dev "${loopdev}")
            if [ -n "$offset" ]; then
                losetup -o "$offset" "$dev" "$fspath"
            else
                losetup "$dev" "$fspath"
            fi
            echo "$dev"
            return 0
        fi
    done
    panic "No loop devices available"
}

remove_loop() {
    local fspath=$1

    for loopdev in "/dev/loop"*; do
    	loop_fspath=$(losetup ${loopdev} | awk '{print $3}' | tr -d '()')
	if [ "${loop_fspath}" = "${fspath}" ]; then
	    losetup -d "${loopdev}"
	    return 0
	fi
    done
    return 1
}

try_mount ()
{
    dev="${1}"
    mountp="${2}"
    opts="${3}"

    if where_is_mounted ${dev} > /dev/null; then
        mount -o remount,"${opts}" ${dev} $(where_is_mounted ${dev}) || panic "Remounting failed"
        mount -o bind $(where_is_mounted ${dev}) ${mountp} || panic "Cannot bind-mount"
    else
        mount -t $(get_fstype "${dev}") -o "${opts}" "${dev}" "${mountp}" || panic "Cannot mount ${dev} on ${mountp}"
    fi
}

crypto_open () {
    crypto_dev="${1}"
    crypto_map="${2}"
    crypto_key="${3}"

    modprobe ${MP_QUIET} -b dm-crypt

    crypto_loop=$(setup_loop "${crypto_dev}" "loop" "/sys/block/loop*")

    if /sbin/cryptsetup isLuks ${crypto_loop} > /dev/null 2>&1; then
	crypto_open_cmd="/sbin/cryptsetup -q luksOpen ${crypto_loop} ${crypto_map}"

	if ${crypto_open_cmd} --key-file="${crypto_key}" > /dev/null 2>&1; then
	    if [ -e "/dev/mapper/${crypto_map}" ]; then
		return 0	    
	    else
		log_warning_msg "cryptsetup: unknown error setting up device mapping"
		return 1
	    fi
	else
#	    if [ -x "/sbin/usplash_write" -a -p /dev/.initramfs/usplash_outfifo ]; then
#		/sbin/usplash_write "QUIT"
#		# saftey sleep to make sure the vt switch happened correctly
#		sleep 2
#	    fi

    	    count=0
	    while [ $count -lt 3 ]; do
		count=$(( $count + 1 ))
		echo -n "Enter passphrase for ${crypto_map}: " >&6
		read -s passphrase
		echo >&6
		echo "${passphrase}" | ${crypto_open_cmd}

		if [ $? -eq 0 ]; then
		    if [ -e "/dev/mapper/${crypto_map}" ]; then
			# todo: ASK USER, ADD KEY + DONT BOTHER
			echo "Passphrase accepted" >&6
			echo >&6
			return 0
		    else
			log_warning_msg "cryptsetup: unknown error setting up device mapping"
			return 1
		    fi
		else
		    echo "Passphrase declined" >&6
		    echo >&6
		fi
	    done
	    echo "Maximum number of tries exceeded, skipping ${crypto_map}..." >&6
	fi
    else
	log_warning_msg "Device ${crypto_dev} is not a Luks device"
    fi
    return 1
}

crypto_close () {
    crypto_dev="${1}"
    crypto_map=$(basename "${crypto_dev}")
    /sbin/cryptsetup -q luksClose "${crypto_map}" > /dev/null 2>&1
    remove_loop "${crypto_dev}"
}


process_personalize_conf () {
    personalize_conf="${1}"
    if [ ${personalize_conf} ]; then
	. ${personalize_conf}
	# USERPASSWORD will be equivalent to live user
	export USERNAME USERFULLNAME HOST
    else
	log_warning_msg "Unable to find personalize configuration file: ${personalize_conf}"
    fi
}

process_pdevs_conf () {
    pdevs_conf="${1}"
    if [ ${pdevs_conf} ]; then
	cat ${pdevs_conf} | grep -v \# |
	while read p_label p_mountp p_overlay p_crypto; do
	    if [ ${p_label} ]; then
		p_device=$(probe_persistence "${p_label}")
		if [ ${p_device} ]; then
		    if [ "${p_overlay}" = "true" ]; then
			case ${p_crypto} in
			    none)
				cow_mountp="/cow_${p_label}"
				mkdir -p "${cow_mountp}"
				try_mount "${p_device}" "${cow_mountp}" "loop"
				;;
			    luks)
				p_key="/pdevs/${p_label}.key"
				p_map=$(basename "${p_device}")
				crypto_open "${p_device}" "${p_map}" "${p_key}"
				cow_mountp="/cow_${p_label}"
				mkdir -p "${cow_mountp}"
				try_mount "/dev/mapper/${p_map}" "${cow_mountp}" "rw"
				;;
			    *)
				log_warning_msg "Unknown crypto ${p_crypto} for ${p_device}"
				;;
			esac
			mount -t unionfs -o dirs=${cow_mountp}=rw:$rofsstring unionfs "${rootmnt}${p_mountp}"
		    else
			case ${p_crypto} in
			    none)
				try_mount "${p_device}" "${rootmnt}${p_mountp}" "loop"
				;;
			    luks)
				p_key="/pdevs/${p_label}.key"
				p_map=$(basename "${p_device}")
				crypto_open "${p_device}" "${p_map}" "${p_key}"
				try_mount "/dev/mapper/${p_map}" "${rootmnt}${p_mountp}" "rw"
				;;
			    *)
				log_warning_msg "Unknown crypto ${p_crypto} for ${p_device}"
				;;
			esac
		    fi
		else
		    log_warning_msg "Unable to find the persistent device labeled ${p_label}"
		fi
	    fi
	done
	for cow_backing in $(echo /media/* | tr ' ' '\n' | grep -v live); do
	    mkdir -p "${rootmnt}${cow_backing}"
	    mount -o move "${cow_backing}" "${rootmnt}${cow_backing}"
	done
    else
	log_warning_msg "Unable to find pdevs_conf: ${pdevs_conf}"
    fi
}

probe_persistence() {
    pers_label="${1}"
    for sysblock in $(echo /sys/block/* | tr ' ' '\n' | grep -v loop | grep -v dm- ); do
        for dev in $(subdevices "${sysblock}"); do
            devname=$(sys2dev "${dev}")
            if is_supported_blockdev ${devname}; then
		devbasename=$(basename "${devname}")
		cow_backing="/media/${devbasename}"
		if [ -d "${cow_backing}" ]; then
		    if [ -e "${cow_backing}/${pers_label}" ]; then
		        echo "${cow_backing}/${pers_label}"
                        return 0
		    fi
		else
        	    mkdir -p "${cow_backing}"
	            try_mount "${devname}" "${cow_backing}" "rw"
                    if [ -e "${cow_backing}/${pers_label}" ]; then
		        echo "${cow_backing}/${pers_label}"
                        return 0
		    else
                	umount ${cow_backing}
			rmdir ${cow_backing}
		    fi
		fi

            fi
        done
    done
    return 1
}

find_cow_device() {
    pers_label="${1}"
    for sysblock in $(echo /sys/block/* | tr ' ' '\n' | grep -v loop); do
        for dev in $(subdevices "${sysblock}"); do
            devname=$(sys2dev "${dev}")
            if [ "$(/lib/udev/vol_id -l $devname 2>/dev/null)" = "${pers_label}" ]; then
                echo "$devname"
                return
            elif is_supported_blockdev ${devname}; then
		devbasename=$(basename "${devname}")
		cow_backing="${rootmnt}/media/${devbasename}"
                mkdir -p "${cow_backing}"
                try_mount "${devname}" "${cow_backing}" "rw"
                if [ -e "${cow_backing}/${pers_label}" ]; then
                    echo $(setup_loop "${cow_backing}/${pers_label}" "loop" "/sys/block/loop*")
                    return 0
                else
                    umount ${cow_backing}
		    rmdir ${cow_backing}
                fi
            fi
        done
    done
}

find_files()
# return the first of $filenames found on vfat and ext2 devices
# FIXME: merge with above function
{
    filenames="${1}"
    snap_backing="/snap-backing"
    for sysblock in $(echo /sys/block/* | tr ' ' '\n' | grep -v loop); do
        for dev in $(subdevices "${sysblock}"); do
            devname=$(sys2dev "${dev}")
            devfstype="$(get_fstype ${devname})"
            if [ "${devfstype}" = "vfat" ] ||  [ "${devfstype}" = "ext2" ] ; then # FIXME: all supported block devices should be scanned
                mkdir -p "${snap_backing}"
                try_mount "${devname}" "${snap_backing}" "ro"
                for filename in ${filenames}; do
                    if [ -e "${snap_backing}/${filename}" ]; then
                        echo "${devname} ${snap_backing} ${filename}"
                        return 0
                    fi
                done
                umount ${snap_backing}
            fi
        done
    done
}


